// document.addEventListener('DOMContentLoaded', function () {
//     // URL to your dataset file
//     const datasetUrl = 'malware_dataset.csv';

//     // Function to fetch dataset
//     async function fetchDataset() {
//         try {
//             const response = await fetch(datasetUrl);
//             const data = await response.text();
//             processData(data);
//         } catch (error) {
//             console.error('Error fetching dataset:', error);
//         }
//     }

//     // Function to process dataset
//     function processData(data) {
//         // Parse CSV data
//         const rows = data.trim().split('\n').slice(1); // Exclude header row

//         // Data for visualization
//         const maliciousCounts = {
//             'YES': 0,
//             'NO': 0
//         };
//         const downloadSourceCounts = {};
//         const tldCounts = {};
//         const downloadSpeedCounts = {};
//         const executableCodeCounts = {};

//         // Extract data from each row
//         for (const row of rows) {
//             const cols = row.split(',');
            
//             const isMalicious = cols[cols.length - 2].trim(); // Last but one column contains "Actually Malicious" entry
//             maliciousCounts[isMalicious]++;

//             const downloadSource = cols[1].trim(); // Download Source column
//             downloadSourceCounts[downloadSource] = (downloadSourceCounts[downloadSource] || 0) + 1;

//             const tld = cols[2].trim(); // TLD column
//             tldCounts[tld] = (tldCounts[tld] || 0) + 1;

//             const downloadSpeed = cols[3].trim(); // Download Speed column
//             downloadSpeedCounts[downloadSpeed] = (downloadSpeedCounts[downloadSpeed] || 0) + 1;

//             const executableCode = cols[7].trim(); // Executable Code column
//             executableCodeCounts[executableCode] = (executableCodeCounts[executableCode] || 0) + 1;
//         }

//         // Visualization 1: Malware Distribution (Pie Chart)
//         createPieChart('malwarePieChart', 'Malware Distribution', ['Malicious', 'Clean'], [maliciousCounts['YES'], maliciousCounts['NO']], ['rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)']);

//         // Visualization 2: Comparison between Download Source and Malicious (Bar Chart)
//         createBarChart('downloadSourceBarChart', 'Comparison between Download Source and No. of Files', Object.keys(downloadSourceCounts), Object.values(downloadSourceCounts), 'white');

//         // Visualization 3: Top Level Domains and Malicious (Doughnut Chart)
//         createDoughnutChart('tldDoughnutChart', 'Top Level Domains', Object.keys(tldCounts), Object.values(tldCounts), ['rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)', 'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)']);

//         // Visualization 4: Download Speed and Top Level Domains (Bar Chart)
//         createBarChart('downloadSpeedBarChart', 'Downloded Files and Top Level Domains', Object.keys(tldCounts),Object.values(downloadSpeedCounts),  'rgba(153, 102, 255, 0.7)');

//         // Visualization 5: Executable Code and Malicious (Doughnut Chart)
//         createDoughnutChart('executableCodeDoughnutChart', 'Executable Code and Malicious', Object.keys(executableCodeCounts), Object.values(executableCodeCounts), ['rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)']);
//     }

//     // Function to create a pie chart
//     function createPieChart(canvasId, label, labels, data, backgroundColors) {
//         const ctx = document.getElementById(canvasId).getContext('2d');
//         new Chart(ctx, {
//             type: 'pie',
//             data: {
//                 labels: labels,
//                 datasets: [{
//                     label: label,
//                     data: data,
//                     backgroundColor: backgroundColors,
//                     borderWidth: 1
//                 }]
//             }
//         });
//     }

//     // Function to create a bar chart
//     function createBarChart(canvasId, label, labels, data, backgroundColor) {
//         const ctx = document.getElementById(canvasId).getContext('2d');
//         new Chart(ctx, {
//             type: 'bar',
//             data: {
//                 labels: labels,
//                 datasets: [{
//                     label: label,
//                     data: data,
//                     backgroundColor: backgroundColor,
//                     tension: 0.4,
//                     borderWidth: 0,
//                     borderRadius: 4,
//                     borderSkipped: false,
//                     maxBarThickness: 60
//                 }]
//             },
//             options: {
//                 responsive: true,
//                 maintainAspectRatio: false,
//                 plugins: {
//                   legend: {
//                     display: false,
//                   }
//                 },
//                 interaction: {
//                   intersect: false,
//                   mode: 'index',
//                 },
//                 scales: {
//                     y: {
//                         beginAtZero: true,
//                         grid: {
//                             drawBorder: false,
//                             display: true,
//                             drawOnChartArea: true,
//                             drawTicks: false,
//                             borderDash: [5, 5],
//                             color: 'rgba(255, 255, 255, .2)'
//                           },
//                           ticks: {
//                             suggestedMin: 0,
//                             suggestedMax: 500,
//                             beginAtZero: true,
//                             padding: 10,
//                             font: {
//                               size: 14,
//                               weight: 300,
//                               family: "Roboto",
//                               style: 'normal',
//                               lineHeight: 2
//                             },
//                             color: "#fff"
//                           },
//                     },
//                     x: {
//                         grid: {
//                           drawBorder: false,
//                           display: true,
//                           drawOnChartArea: true,
//                           drawTicks: false,
//                           borderDash: [5, 5],
//                           color: 'rgba(255, 255, 255, .2)'
//                         },
//                         ticks: {
//                           display: true,
//                           color: '#f8f9fa',
//                           padding: 10,
//                           font: {
//                             size: 14,
//                             weight: 300,
//                             family: "Roboto",
//                             style: 'normal',
//                             lineHeight: 2
//                           },
//                         }
//                       },
//                 }
//             }
//         });
//     }

//     // Function to create a doughnut chart
//     function createDoughnutChart(canvasId, label, labels, data, backgroundColors) {
//         const ctx = document.getElementById(canvasId).getContext('2d');
//         new Chart(ctx, {
//             type: 'doughnut',
//             data: {
//                 labels: labels,
//                 datasets: [{
//                     label: label,
//                     data: data,
//                     backgroundColor: backgroundColors,
//                     borderWidth: 1
//                 }]
//             }
//         });
//     }

//     // Call fetchDataset function to load dataset
//     fetchDataset();

//     //-------------------------------------------------------------------------------------------------------------------------

// });

// async function trainAndPredict() {
//     const model = await createModel();
//     const data = await fetchData();
//     const { features, labels } = preprocessData(data);
//     await trainModel(model, features, labels);

//     const fileInput = document.getElementById('fileInput');
//     fileInput.addEventListener('change', async (event) => {
//         const file = event.target.files[0];
//         const newData = await parseCSV(file);
//         const prediction = predict(model, newData);
//         document.getElementById('predictionResult').innerText = `Prediction: ${prediction}`;
//     });
// }

// async function createModel() {
//     const model = tf.sequential();
//     model.add(tf.layers.dense({ units: 10, inputShape: [4], activation: 'relu' }));
//     model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
//     model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy'] });
//     return model;
// }

// async function fetchData() {
//     // If you have an existing dataset URL, fetch it here
//     const datasetUrl = 'malware_dataset.csv';
    
//     try {
//         // Fetch the dataset
//         const response = await fetch(datasetUrl);
//         // Parse the CSV data
//         const data = await response.text();
//         // Process the data as needed
//         const processedData = processData(data);
//         return processedData;
//     } catch (error) {
//         console.error('Error fetching dataset:', error);
//         return null;
//     }
// }


// function preprocessData(data) {
//     // Parse CSV data into rows
//     const rows = data.trim().split('\n').slice(1); // Exclude header row

//     // Initialize arrays to store features and labels
//     const features = [];
//     const labels = [];

//     // Process each row
//     rows.forEach(row => {
//         // Split row into columns
//         const cols = row.split(',');

//         // Extract features (excluding the last column which contains the label)
//         const featureRow = cols.slice(0, cols.length - 1).map(Number); // Assuming features are numeric
//         features.push(featureRow);

//         // Extract label (last column)
//         const label = Number(cols[cols.length - 1].trim()); // Assuming label is numeric
//         labels.push(label);
//     });

//     // Convert arrays to TensorFlow tensors
//     const featuresTensor = tf.tensor2d(features);
//     const labelsTensor = tf.tensor1d(labels);

//     return { features: featuresTensor, labels: labelsTensor };
// }


// async function trainModel(model, features, labels) {
//     await model.fit(features, labels, { epochs: 10 });
// }

// async function parseCSV(file) {
//     return new Promise((resolve, reject) => {
//         const reader = new FileReader();

//         // Event listener for when the file is loaded
//         reader.onload = (event) => {
//             const csvData = event.target.result;
//             const parsedData = processData(csvData); // Assuming processData is defined elsewhere to handle CSV parsing
//             resolve(parsedData);
//         };

//         // Event listener for file read errors
//         reader.onerror = (error) => {
//             console.error('Error reading file:', error);
//             reject(error);
//         };

//         // Read the file as text
//         reader.readAsText(file);
//     });
// }


// function predict(model, newData) {
//     // Convert the new data into a TensorFlow tensor
//     const inputData = tf.tensor2d([newData]);

//     // Use the trained model to make predictions
//     const prediction = model.predict(inputData);

//     // Get the prediction value
//     const predictedValue = prediction.dataSync()[0];

//     // You can add a threshold if needed
//     // For example, if the predicted value is greater than 0.5, classify it as malware
//     // Otherwise, classify it as clean
//     const classification = predictedValue > 0.5 ? 'Malware' : 'Clean';

//     return classification;
// }


document.addEventListener('DOMContentLoaded', function () {
    // URL to your dataset file
    const datasetUrl = 'malware_dataset.csv';

    // Function to fetch dataset
    async function fetchDataset() {
        try {
            const response = await fetch(datasetUrl);
            const data = await response.text();
            processData(data);
        } catch (error) {
            console.error('Error fetching dataset:', error);
        }
    }

    // Function to process dataset
    function processData(data) {
        // Parse CSV data
        const rows = data.trim().split('\n').slice(1); // Exclude header row

        // Data for visualization
        const maliciousCounts = {
            'YES': 0,
            'NO': 0
        };
        const downloadSourceCounts = {};
        const tldCounts = {};
        const downloadSpeedCounts = {};
        const executableCodeCounts = {};

        // Extract data from each row
        for (const row of rows) {
            const cols = row.split(',');
            
            const isMalicious = cols[cols.length - 2].trim(); // Last but one column contains "Actually Malicious" entry
            maliciousCounts[isMalicious]++;

            const downloadSource = cols[1].trim(); // Download Source column
            downloadSourceCounts[downloadSource] = (downloadSourceCounts[downloadSource] || 0) + 1;

            const tld = cols[2].trim(); // TLD column
            tldCounts[tld] = (tldCounts[tld] || 0) + 1;

            const downloadSpeed = cols[3].trim(); // Download Speed column
            downloadSpeedCounts[downloadSpeed] = (downloadSpeedCounts[downloadSpeed] || 0) + 1;

            const executableCode = cols[7].trim(); // Executable Code column
            executableCodeCounts[executableCode] = (executableCodeCounts[executableCode] || 0) + 1;
        }

        // Visualization 1: Malware Distribution (Pie Chart)
        createPieChart('malwarePieChart', 'Malware Distribution', ['Malicious', 'Clean'], [maliciousCounts['YES'], maliciousCounts['NO']], ['rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)']);

        // Visualization 2: Comparison between Download Source and Malicious (Bar Chart)
        createBarChart('downloadSourceBarChart', 'Comparison between Download Source and No. of Files', Object.keys(downloadSourceCounts), Object.values(downloadSourceCounts), 'white');

        // Visualization 3: Top Level Domains and Malicious (Doughnut Chart)
        createDoughnutChart('tldDoughnutChart', 'Top Level Domains', Object.keys(tldCounts), Object.values(tldCounts), ['rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)', 'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)']);

        // Visualization 4: Download Speed and Top Level Domains (Bar Chart)
        createBarChart('downloadSpeedBarChart', 'Downloded Files and Top Level Domains', Object.keys(tldCounts),Object.values(downloadSpeedCounts),  'rgba(153, 102, 255, 0.7)');

        // Visualization 5: Executable Code and Malicious (Doughnut Chart)
        createDoughnutChart('executableCodeDoughnutChart', 'Executable Code and Malicious', Object.keys(executableCodeCounts), Object.values(executableCodeCounts), ['rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)']);
    }

    // Function to create a pie chart
    function createPieChart(canvasId, label, labels, data, backgroundColors) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    backgroundColor: backgroundColors,
                    borderWidth: 1
                }]
            }
        });
    }

    // Function to create a bar chart
    function createBarChart(canvasId, label, labels, data, backgroundColor) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    backgroundColor: backgroundColor,
                    tension: 0.4,
                    borderWidth: 0,
                    borderRadius: 4,
                    borderSkipped: false,
                    maxBarThickness: 60
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: {
                    display: false,
                  }
                },
                interaction: {
                  intersect: false,
                  mode: 'index',
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            drawBorder: false,
                            display: true,
                            drawOnChartArea: true,
                            drawTicks: false,
                            borderDash: [5, 5],
                            color: 'rgba(255, 255, 255, .2)'
                          },
                          ticks: {
                            suggestedMin: 0,
                            suggestedMax: 500,
                            beginAtZero: true,
                            padding: 10,
                            font: {
                              size: 14,
                              weight: 300,
                              family: "Roboto",
                              style: 'normal',
                              lineHeight: 2
                            },
                            color: "#fff"
                          },
                    },
                    x: {
                        grid: {
                          drawBorder: false,
                          display: true,
                          drawOnChartArea: true,
                          drawTicks: false,
                          borderDash: [5, 5],
                          color: 'rgba(255, 255, 255, .2)'
                        },
                        ticks: {
                          display: true,
                          color: '#f8f9fa',
                          padding: 10,
                          font: {
                            size: 14,
                            weight: 300,
                            family: "Roboto",
                            style: 'normal',
                            lineHeight: 2
                          },
                        }
                      },
                }
            }
        });
    }

    // Function to create a doughnut chart
    function createDoughnutChart(canvasId, label, labels, data, backgroundColors) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    backgroundColor: backgroundColors,
                    borderWidth: 1
                }]
            }
        });
    }

    // Call fetchDataset function to load dataset
    fetchDataset();

    //-------------------------------------------------------------------------------------------------------------------------

});

async function trainAndPredict() {
    const model = await createModel();
    const data = await fetchData();
    const { features, labels } = preprocessData(data);
    await trainModel(model, features, labels);

    const fileInput = document.getElementById('fileInput');
    fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        const newData = await parseCSV(file);
        const prediction = predict(model, newData);
        document.getElementById('predictionResult').innerText = `Prediction: ${prediction}`;
    });
}

async function createModel() {
    const model = tf.sequential();
    model.add(tf.layers.dense({ units: 10, inputShape: [4], activation: 'relu' }));
    model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
    model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy'] });
    return model;
}

async function fetchData() {
    // If you have an existing dataset URL, fetch it here
    const datasetUrl = 'malware_dataset.csv';
    
    try {
        // Fetch the dataset
        const response = await fetch(datasetUrl);
        // Parse the CSV data
        const data = await response.text();
        // Return the data
        return data;
    } catch (error) {
        console.error('Error fetching dataset:', error);
        return null;
    }
}

function preprocessData(data) {
    // Parse CSV data into rows
    const rows = data.trim().split('\n').slice(1); // Exclude header row

    // Initialize arrays to store features and labels
    const features = [];
    const labels = [];

    // Process each row
    rows.forEach(row => {
        // Split row into columns
        const cols = row.split(',');

        // Extract features (excluding the last column which contains the label)
        const featureRow = cols.slice(0, cols.length - 1).map(Number); // Assuming features are numeric
        features.push(featureRow);

        // Extract label (last column)
        const label = Number(cols[cols.length - 1].trim()); // Assuming label is numeric
        labels.push(label);
    });

    // Convert arrays to TensorFlow tensors
    const featuresTensor = tf.tensor2d(features);
    const labelsTensor = tf.tensor1d(labels);

    return { features: featuresTensor, labels: labelsTensor };
}



async function trainModel(model, features, labels) {
    await model.fit(features, labels, { epochs: 10 });
}

async function parseCSV(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        // Event listener for when the file is loaded
        reader.onload = (event) => {
            const csvData = event.target.result;
            resolve(csvData);
        };

        // Event listener for file read errors
        reader.onerror = (error) => {
            console.error('Error reading file:', error);
            reject(error);
        };

        // Read the file as text
        reader.readAsText(file);
    });
}

function predict(model, newData) {
    // Convert the new data into a TensorFlow tensor
    const inputData = tf.tensor2d([newData]);

    // Use the trained model to make predictions
    const prediction = model.predict(inputData);

    // Get the prediction value
    const predictedValue = prediction.dataSync()[0];

    // You can add a threshold if needed
    // For example, if the predicted value is greater than 0.5, classify it as malware
    // Otherwise, classify it as clean
    const classification = predictedValue > 0.5 ? 'Malware' : 'Clean';

    return classification;
}
